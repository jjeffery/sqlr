// Code generated by "sqlr-gen"; DO NOT EDIT

package testdata

import (
	"github.com/jjeffery/errors"
	"github.com/jjeffery/sqlr/private/codegen/testdata/rowtype"
)

// get retrieves a Row4 by its primary key. Returns nil if not found.
func (q *Row4Query) get(id rowtype.Row4ID) (*rowtype.Row4, error) {
	var row rowtype.Row4
	n, err := q.schema.Select(q.db, &row, "select {} from rowtype._row4s where {}", id)
	if err != nil {
		return nil, errors.Wrap(err, "cannot get Row4").With(
			"id", id,
		)
	}
	if n == 0 {
		return nil, nil
	}
	return &row, nil
}

// selectRows returns a list of Row4s from an SQL query.
func (q *Row4Query) selectRows(query string, args ...interface{}) ([]*rowtype.Row4, error) {
	var rows []*rowtype.Row4
	_, err := q.schema.Select(q.db, &rows, query, args...)
	if err != nil {
		return nil, errors.Wrap(err, "cannot query Row4s").With(
			"query", query,
			"args", args,
		)
	}
	return rows, nil
}

// selectRow selects a Row4 from an SQL query. Returns nil if the query returns no rows.
// If the query returns one or more rows the value for the first is returned and any subsequent
// rows are discarded.
func (q *Row4Query) selectRow(query string, args ...interface{}) (*rowtype.Row4, error) {
	var row rowtype.Row4
	n, err := q.schema.Select(q.db, &row, query, args...)
	if err != nil {
		return nil, errors.Wrap(err, "cannot query one Row4").With(
			"query", query,
			"args", args,
		)
	}
	if n == 0 {
		return nil, nil
	}
	return &row, nil
}

// insert inserts a Row4 row.
func (q *Row4Query) insert(row *rowtype.Row4) error {
	_, err := q.schema.Exec(q.db, row, "insert into rowtype._row4s({}) values({})")
	if err != nil {
		return errors.Wrap(err, "cannot insert Row4").With(
			"ID", row.ID,
		)
	}
	return nil
}

// update updates an existing Row4 row. Returns the number of rows updated,
// which should be zero or one.
func (q *Row4Query) update(row *rowtype.Row4) (int, error) {
	n, err := q.schema.Exec(q.db, row, "update rowtype._row4s set {} where {}")
	if err != nil {
		return 0, errors.Wrap(err, "cannot update Row4").With(
			"ID", row.ID,
		)
	}
	return n, nil
}

// upsert attempts to update a Row4 row, and if it does not exist then insert it.
func (q *Row4Query) upsert(row *rowtype.Row4) error {
	n, err := q.schema.Exec(q.db, row, "update rowtype._row4s set {} where {}")
	if err != nil {
		return errors.Wrap(err, "cannot update Row4 for upsert").With(
			"ID", row.ID,
		)
	}
	if n > 0 {
		// update successful, row updated
		return nil
	}
	if _, err := q.schema.Exec(q.db, row, "insert into rowtype._row4s({}) values({})"); err != nil {
		return errors.Wrap(err, "cannot insert Row4 for upsert").With(
			"ID", row.ID,
		)
	}
	return nil
}

// delete deletes a Row4 row. Returns the number of rows deleted, which should
// be zero or one.
func (q *Row4Query) delete(row *rowtype.Row4) (int, error) {
	n, err := q.schema.Exec(q.db, row, "delete from rowtype._row4s where {}")
	if err != nil {
		return 0, errors.Wrap(err, "cannot delete Row4").With(
			"ID", row.ID,
		)
	}
	return n, nil
}
